---
layout: post
title: "《大型网站系统与Java中间件实践》读书摘要"
description: 
modified: 2016-01-08
category: Web
tags: [Web,Java]
comments: true
mathjax: 
---
{% highlight linenos %}
{% endhighlight %}


- 分布式系统介绍

   - 定义：分布式系统是一个组件分布在网络计算机上，组件间仅仅通过消息传递来通信并协调行动

    - 意义：

        - 升级单机处理能力的性价比越来越低

        - 单机处理能力存在瓶颈

        - 出于稳定性和可用性考虑

    - 组成计算机的基本元素

        - 输入设备

            - 在分布式中不仅有人机交互，还有接收节点间的信息

        - 输出设备

            - 在分布式中不仅有人机交互，还有向其他节点发信息

        - 运算器

        - 控制器

            - 在分布式中主要是协调或控制节点间的动作和行为

            - 方式一：硬件负载均衡：

                - 请求转发

            - 方式二：软件负载均衡(LVS)；透明代理

                - 代价低、可控性强、可按照需要增加策略

                - 不足：

                    - 增加网络开销；流量开销（仅在发送请求的数据包很大时网络开销才会增加明显）；延迟

                    - 代理出现问题所有请求受影响

            - 方式三：采用名称服务的直连方式的请求调用

                - 名称服务作用

                    - 收集提供请求处理的服务器地址信息

                    - 提供这些地址信息给请求发起方

                - 不足：

                    - 代码升级复杂

            - 方式四：采用规则服务器控制路由的请求直接调用

                - 和名称服务的不同

                    - 名称服务通过跟请求处理的机器交互来获取机器地址，规则服务器本身并不和请求处理的机器进行交互，只负责把规则提供给请求发起的机器

            - 方式五：采用Master-Worker模式
                - Master管理任务，把任务分配给不同的Worker处理

        - 存储器

            - 内存：断电丢失

            - 外存：断电不失

    - 线程与进程

        - 多线程开发中，需要处理线程间通信，对线程并发做控制，做好线程间协调工作

    - 阿姆达尔定律
        - S(N) = 1/((1-P)+P/N)
        - P指程序中可并行部分的程序在单核上执行时间的占比
        - N表示处理器的个数(总核心数)
        - S(N)指程序在N个处理器(总核心数)相对在单个处理器中的速度提升比

        - 示例：http://ifeve.com/amdahls-law/

    - 避免死锁

        - 能原子性的获取需要的多个锁

        - 注意调整对多个锁的获取顺序

    - 网络IO实现方式
        - BIO
            - Blocking IO:采用阻塞方式实现

            - 一个套接字使用一个线程来处理
        - NIO
            - Nonblocking IO:基于事件驱动思想，采用Reactor模式

            - 可以在一个线程中处理多个Socket套接字相关工作

            - 由Reactor统一对所有客户端Socket套接字事件做处理，然后派发到不同的线程
        - AIO
            - AsynchronousIO:Proactor模式

            - 在进行读写操作时，只需要调用read/write方法，并且需要传入CompletionHandler（动作完成处理器），动作完成后会调用CompletionHandler
            - NIO的通知发生在动作之前，在可读、可写的时候，Selector发现这些事件后调用Handler处理。
        - NIO与AIO区别
            - NIO有通知时可以进行相关操作，AIO通知时表示相关操作已完成

    - 分布式系统的难点

        - 缺乏全局时钟

        - 面对故障独立性

        - 单点故障（SPoF：Single Point of Failure）

            - 给单点做备份

            - 降低单点影响范围

        - 事务的挑战

            - 两阶段提交(2PC)

                - 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。

            - 最终一致

                - 根据更新数据后各进程访问到数据的时间和方式的不同,又可以区分为：

                - 因果一致性.如果进程A通知进程B它已更新了一个数据项,那么进程B的后续访问将返回更新后的值,且一次写入将保证取代前一次写入.与进程A无因果关系的进程C的访问遵守一般的最终一致性规则.
                - “读己之所写(read-your-writes)”一致性.当进程A自己更新一个数据项之后,它总是访问到更新过的值,绝不会看到旧值.这是因果一致性模型的一个特例.

                - 会话(Session)一致性.这是上一个模型的实用版本,它把访问存储系统的进程放到会话的上下文中.只要会话还存在,系统就保证“读己之所写”一致性.如果由于某些失败情形令会话终止,就要建立新的会话,而且系统的保证不会延续到新的会话.

                - 单调(Monotonic)读一致性.如果进程已经看到过数据对象的某个值,那么任何后续访问都不会返回在那个值之前的值.

                - 单调写一致性.系统保证来自同一个进程的写操作顺序执行.要是系统不能保证这种程度的一致性,就非常难以编程了.
            - BASE
                - Basically Available

                    - 基本可用，允许分区失败
                - Soft state

                    - 软状态，接受一段时间的状态不同步
                - Eventually consistent

                    - 最终一致，保证最终数据是一致的
            - CAP
                - Consistency:一致性
                - Availability:可用性；保证无论成功还是失败都能有一个反馈
                - Partition-Tolerance：分区容忍；即使系统中有部分问题或有消息丢失，但系统能继续运行

                - 由于不能同时满足三项，设计与权衡就是选择两项
                    - CA:

                        - 传统的单机数据库：放弃分区容忍性
                    - AP:

                        - 分布式系统的设计：放弃一致性
                    - CP:网络的问题会让系统不可用：放弃可用性
            - Paxos

                - 前提：信息都是准确的

- 大型网站及其架构的演进

    - 单机—>数据库与应用分离—>应用服务器走向集群—>读写分离

    - 应用服务器走向集群

        - 引入负载均衡设备

        - 解决Session问题
            - Session Sticky

                - 保证同一会话的请求都在同一Web服务器上处理

                - 问题

                    - 服务器宕机或重启，此机器上所有会话丢失

                    - 会话标识是应用层信息，负载均衡若将请求保存到同一Web服务器，进行应用层解析(第七层)，开销大

                    - 负载均衡变为了一个有状态节点，内存开销大，容灾麻烦
            - Session Replication

                - 在Web服务器中增加会话数据的同步

                - 问题

                    - 网络带宽的开销，Session有变化就需将数据同步到所有机器

                    - 集群Session多的话，每台服务器保存的数据占用资源过大
            - Session 数据集中存储

                - 问题

                    - 读写Session引入网络操作，延时、不稳定

                    - 存储Session的服务器有问题，影响应用
            - Cookie Based

                - 问题
                    - Cookie长度限制

                    - 安全性

                    - 带宽消耗

                    - 性能；每次请求都有Session，同样的处理情况下，响应的结果输出少，支持的并发请求数多

        - 数据库问题

            - 读写分离，增加读库

            - 搜索引擎成为读库

            - 缓存

                - 数据缓存

                    - 加速应用在响应请求时的数据读取速度

                - 页面缓存
                    - Client Side Includes(CSI)：

                        - 通过iframe、javascript、ajax 等方式将另外一个页面的内容动态包含进来实现动态化。

                        - 优点：

                            - 能够利用浏览器客户端并行处理及装载的机制；这种技术基本不需要服务器支持和修改，计算和操作放在客户端，能够降低服务器端压力

                        - 缺点：

                            - 搜索引擎优化问题；javascript兼容性问题；客户端缓存可能导致服务器端内容更新后不能及时生效。需要通过加 js version 来解决。

                    -  Server Side Includes(SSI)：
                        - SSI它就是HTML文件中，可以通过注释行调用的命令或指针。实现整个网站的内容更新。

                        - 优点：
                            - SSI技术是通用技术，不受具体语言限制，只需要Web服务器或应用服务器支持即可，Ngnix、Apache、Tomcat、Jboss等对此都有较好的支持，目前 Squid 不支持。

                        - 缺点：
                            - SSI在语法上不能够直接包含其他服务器的url，只能在当前服务器上运行。所以通过 CDN 之类的 Cache 时，还是会失效，不灵活.

                    - Edge Side Includes (ESI)：
                        - Edge Side Includes(ESI) 和Server Side Includes(SSI)和功能类似。ESI是一种数据缓冲/缓存服务器，它提供将Web网页的部分（这里指页面的片段）进行缓冲/缓存的技术及服务。ESI是部分地缓冲网页，使用基于XML的标记语言，指示想要缓冲的页面部分。由此，页面内分为动态地变更的部分和静态的不变更的部分(网站内的共通菜单等)，只将静态的部分有效地发送到服务器中。因此可以有效降低原服务器的负载，同时提高用户访问的响应时间。

                        - 优点：
                            - ESI更适合用于缓存服务器上，缓存整个页面或页面片段，因此ESI特别适合用于缓存，CDN 的第一名的老大，Akamai 全力支持协议。对于布置和 Cache 都是最友好的。

                        - 缺点：

                            - 出来很久，一直没有多少人使用。

                    - ESI

                        - 从缓存中获取ESI标签对应的内容

                        - 不存在时，Apache中的模板通过Web服务器渲染

            - 分布式存储系统

            - 数据垂直拆分

            - 数据水平拆分

        - 应用问题

            - 拆分应用

                - 根据业务的特性

                - 按照功能拆分

    - 走向服务化

        - 最上层是Web系统

        - 中间是服务中心

        - 最下是数据库

    - 消息中间件

        - 面向消息的系统（消息中间件）是在分布式系统中完成消息的发送和接收的基础软件
- Java中间件

    - 远程过程调用和对象访问中间件

        - 分布式环境下应用的互相访问

    - 消息中间件

        - 消息的传递、异步、解耦

    - 数据访问中间件

        - 应用访问数据库

    - 垃圾回收
        - Oracle Hotspot JVM

            - 新生代、年老代、持久代

- 服务框架
    - SOA

        - 面向服务体系架构
    - ESB

        - 企业服务总线

    - 差异

        - 服务框架是一个点对点的服务模型，ESB是一个总线式模型

        - 服务框架面向同构系统，不会重点考虑整合需求；ESB会更多的考虑不同厂商所提供服务的整合

- 数据访问层

    - 数据库减压方案

        - 优化应用

        - 降低数据库压力

            - 引入缓存、加搜索引擎

        - 把数据和访问分到多台数据

    - 垂直拆分水平拆分的影响

        - 垂直

            - 单机的ACID被打破

                - 解决

                    - 放弃单机事务

                    - 引入分布式事务
            - Join比较困难

            - 靠外键约束的场景受影响

        - 水平
            - ACID被打破
            - Join困难

            - 外键约束的场景受影响

            - 依赖单库自增的ID受影响

            - 针对单个逻辑意义上的表查询要跨库

    - 多机的数据查询

        - 跨库join

            - 在应用层把原来的数据库的join操作分成多次的数据库操作

            - 对一些常用信息进行冗余

            - 借助外部系统；eg:搜索引擎

    - 对外提供数据访问方式

        - 提供专有API

        - 通用方式：JDBC
        - ORM：iBatis、hibernate、SpringJDBC

- 构建大型网站的其他要素

    - 加速静态内推访问的速度CDN

        - 一种网络缓存技术
        - Content Delivery Network 内容分发网络

            - 把用户需要的内容分发到离用户近的地方
            - CDN系统分为CDN源站和CDN节点，CDN源站提供CDN节点使用的数据源头，CDN节点部署在离用户较近的地方

        - 一般访问流程

            - 用户提交域名

            - 浏览器对域名进行解析，得到对应的IP

            - 浏览器向所得到的IP地址发送请求

            - 根据返回的数据显示网页内容

        - 引入CDN后访问流程

            - 提交域名

            - 浏览器对域名进行解析
            - CDN域名服务器返回指定域名的CNAME记录

            - 对CNAME记录进行再解析

            - 得到CDN地址

            - 向得到CDN的IP地址发出请求
            - CDN若存在缓存内容则返回需要内容，若不存在，从源站获取

        - 关键技术

            - 全局调度

                - 根据用户地域、接入运营商以及CDN机房负载进行调度

            - 缓存技术

                - 使用内存+SSD+机器硬盘的混合存储方式来提升整体缓存容量

                - 做好冷热数据的交换

                - 当CDN的cache没命中的时候，合并同样的数据请求

                - 新增、变更数据后的CDN预加载；需要源站的通知

            - 内容分发

                - 内容管理系统进行编辑修改后，通过分发系统分发到各个CDN节点，保证分发效率、分发文件的一致性、正确性

            - 带宽优化

                - 只返必要的数据，用更好的压缩算法

        - 其它用法

            - 上传的工作从CDN接入，再从CDN传到源站
    - NoSQL
        - Key-Value

            - 没有办法进行高效的范围查询
        - Ordered Key-Value
            - Key有序
        - BigTable

            - 结构化数据的分布式存储系统，对Value进行了Schema支持。Value是由多个Column Family组成，CF内部是Column，不能动态扩展，但是内部可以动态扩展
        - Document,Full-Text Search
            - Document数据库有两个很大的进步，一个是可以在Value中任意自定义复杂的Schema，不仅仅是Map嵌套；另一个是对索引方面的支持
        - Graph

            - 图数据库可以看做是从有序的KV数据库发展来的一个分支

    - 更新索引方式

        - 定时从数据源拉取

            - 延迟

        - 数据变更通知

            - 对系统压力大

    - 倒排索引

        - 相比于正排索引，倒排索引是将值作为索引的key

    - 相关度计算

        - 向量空间模型

        - 概率模型

    - 在线计算Storm流式计算
        - Nimbus（同Hadoop的JobTracker）:负责资源分配和任务调度。
        - Supervisor（同Hadoop的TaskTracker）:负责接受Nimbus分配的任务，启动和停止属于自己管理的Worker
        - Worker(同Hadoop的Child):具体处理组件逻辑的进程
        - Topology（同Hadoop的一个Job）
        - Spout/Bolt(同Hadoop的Mapper/Reducer)
        - Spout是整个处理流程的入口，也是数据的源头，Bolt是整个流中的处理节点
        - Task,Worker中的每一个Spout/Bolt线程称为一个Task。

    - 应用监控系统

        - 数据监视维度
            - CPU使用率

            - 内存使用情况

            - 交换分区使用情况

            - 当前系统负载
            - IO情况

            - 调用次数

            - 成功率

            - 响应时间

            - 异常数量